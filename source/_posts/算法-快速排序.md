---
title: 算法-快速排序
date: 2019-03-08 09:30:00
categories: 算法
tags: [算法,排序,快速排序]
---

# 快速排序

## 思路

快速排序主要利用分治思想，一次排序准确定位单个值的位置，此值作为基准值。

在坏的情况下，每次排序都是相邻的两个数进行了交换。因此快速排序的差时间复杂度和冒泡排序是一样的，都是 O(N^2)，它的平均时间复杂度为 O (NlogN)。

以数组 num[2，1，9，4，3，0，7] 为例，模拟快排算法的过程

- 对整个数组进行排序，基准值为左侧第一位 2
  - 第一次值交换
    - 从右边界 num[5] 开始查找比 2 小的数值，发现 num[5] = 0 是第一个小于2的值
    - 然后从左边界 num[0] 开始查找比 2 大的数值，发现 num[2] = 9 是第一个大于2的值
    - 交换位置，数组变成 num[2，1，0，4，3，9，7]
  - 第二次值交换
    - 从右侧 num[4] 继续查找比 2 小的数值，一直找到 num[2] 左查找下标
    - 此时左查找下标与右查找下标相遇，说明右侧没有比 2 小的值了
    - 将 num[2] 与基准值交换，完成第一个基准值的定位，数组变成 [0，1，2，4，3，9，7]
    - 开始对基准值左侧的数组进行排序，即 [0，1]
      - 同样，以首位 0 作为基准值，开始查找排序，最终获得 [0，1]
      - 此时数组变成 [0，1，2，4，3，9]
    - 开始对基准值右侧的数组进行排序，即 [4，3，9，7]
      - 排序获得 [3，4，9，7]
        - 左侧只有 [3] 不需要排序
        - 右侧是 [4，9，7] 开始排序
          - 排序获得 [4，7，9]
      - 此时数组变成 [0，1，2，3，4，7，9]

排序完成

## 源码

```Java
public class QuickSort {
    public static int[] temp;

    public static void main(String[] args) {
        temp = new int[20];
        // 随机赋值
        System.out.println("before sort");
        for (int i = 0; i < temp.length; i++) {
            temp[i] = (int) (Math.random() * 2000);
            System.out.print(temp[i] + " ");
        }
        System.out.println();

        // 开始排序
        sort(0, temp.length - 1);

        System.out.println("after sort");
        // 输出排序结果
        for (int i = 0; i < temp.length; i++) {
            System.out.print(temp[i] + " ");
        }
    }

    public static void sort(int left, int right) {
        // 将左右边界赋值给左右查找下标
        int lIndex = left;
        int rIndex = right;
        // 当左查找下标小于或等于右查找下标时，结束递归
        if (rIndex <= lIndex)
            return;
        // 基准值
        int stand = temp[lIndex];
        // 仅当左边界小于右边界时，参考基准值对数组进行值交换
        while (lIndex < rIndex) {
            // 从右边界开始查找比基准值小的值
            while (temp[rIndex] >= stand && lIndex < rIndex)
                rIndex--;
            // 从左边界开始查找比基准值大的值
            while (temp[lIndex] <= stand && lIndex < rIndex)
                lIndex++;
            // 将 右边 小于基准值的值 与 左边 大于基准值的值 进行交换
            if (rIndex > lIndex) {
                temp[rIndex] = temp[lIndex] + temp[rIndex];
                temp[lIndex] = temp[rIndex] - temp[lIndex];
                temp[rIndex] = temp[rIndex] - temp[lIndex];
            }
        }
        // 因为查找是从右边开始，故最终两个查找下标相遇的值必定比基准值小
        // 所以将相遇下标值与基准值交换
        // 完成对基准值的定位
        temp[left] = temp[lIndex];
        temp[lIndex] = stand;
        // 对基准值左侧的数组进行递归排序
        sort(left, lIndex - 1);
        // 对基准值右侧的数组进行递归排序
        sort(lIndex + 1, right);
    }
}
```

测试输出

```Java
before sort
1395 9 1010 749 1869 919 197 711 284 1940 799 1208 118 503 500 1226 1041 1084 1598 649 
after sort
9 118 197 284 500 503 649 711 749 799 919 1010 1041 1084 1208 1226 1395 1598 1869 1940 
```

