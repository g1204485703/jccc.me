---
title: Jvm-垃圾收集
date: 2019-03-26 21:00:00
updated: 2019-04-03 18:00:00
categories: Jvm
tags: [Jvm,垃圾收集]
---

# 概述

**垃圾收集（Garbage Collection，GC）**最早起源于Lisp语言，是一种自动的存储管理机制。在Java中，垃圾收集是JVM中重要的组成部分。当需要排查各种内存溢出、内存泄漏问题时，以及垃圾收集称为系统达到更高并发量的瓶颈时，我们就需要对这些“自动化”技术实施必要的监控和调节。

在Java堆中，一个接口的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，只有在程序处于运行期间时才能知道创建哪些对象，这部分内存的分配和回收都是动态的，这就是垃圾收集所关注的内存。

<!--more-->

## 相关概念

### 并发和并行

在谈论垃圾收集器的上下文语境中，它们可以解释为

**并行**：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。

**并发**：指用户线程与垃圾收集线程同时执行（并不一定是并行的，可能会交替执行），用户线程继续运行，而垃圾收集程序运行在另一个CPU上。

### 吞吐量

**吞吐量**就是CPU用于运行用户代码时间与CPU总消耗时间的比值

吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）

### Minor GC、Major GC 和 Full GC

**Minor GC** 指的是从年轻代（包括Eden和Survivor区域）回收内存。

**Major GC** 指的是从老年代回收内存。

**Full GC** 指的是从年轻代和老年代回收内存。

# 对象存活判断算法

## 引用计数法

**引用计数法**是指给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能再被使用的。

引用计数法难以解决对象之间相互循环引用的问题，例如

```Java
public class ReferenceCounting {

    private ReferenceCounting rc;

    public static void main(String[] args) {
        ReferenceCounting rc1 = new ReferenceCounting();
        ReferenceCounting rc2 = new ReferenceCounting();
        rc1.rc = rc2;
        rc2.rc = rc1;

        rc1 = null;
        rc2 = null;
    }
}
```

创建相互引用的`rc1`和`rc2`，随后赋值为`null`。此时因为两对象的相互引用，即使`rc1`,`rc2`都不再指向对象，但是对象的引用计数器都不为0，所以无法被回收。

## 根搜索算法

**根搜索算法**是指通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为*引用链（Reference Chain）*，当一个对象到GC Roots没有任何引用链相连（即从*GC Roots* 到这个对象不可达）时，则证明此对象是不可用的。

如下图中的*Object1*，*Object2*，*Object3*，*Object4*是可以通过*GC Roots* 到达的，即为可用对象；*Object5*，*Object6*，*Object7* 对象之间有关联，但不可通过*GC Roots* 到达，即为不可用对象。

![根搜索算法](/imag/根搜索算法.png)

在Java中，可作为*GC Roots* 的对象包括下面几种

- 虚拟机栈（栈帧中的本地变量表）中的引用的对象
- 方法区中的静态类属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中`native`方法的引用的对象

### 二次标记

在根搜索算法中不可到达的对象，并非是一定会被回收的，真正回收一个对象，至少要经历**两次标记过程**。

#### 第一次标记

如果对象在进行根搜索后发现没有与*GC Roots* 相连接的引用链，那么她将会被第一次标记，并且进行一次筛选，筛选的条件是此对象是否有必要执行`finalize()`方法。当对象没有重写`finalize()`方法，或者`finalize()`方法已经被虚拟机调用过，则被视为没有必要。

如果这个对象被判定为有必要执行`finalize()`方法，那么这个对象会被放置在一个名为**F-Queue**的队列之中，并在稍后由一条虚拟机创建、低优先级的`Finalizer`线程去执行。此处的执行指的是虚拟机会触发这个方法，但并不承诺等待它运行结束。

#### `finalize()`方法

任何一个对象的`finalize()`方法都只会被系统自动调用一次，如果对象面临下一次回收，它的`finalize()`方法不会再次被执行。

并不建议使用`finalize()`方法，因为它不是C/C++中的析构函数，运行代价高昂，不确定性大，无法保证各个对象的调用顺序。`finalize()`方法能做的所有工作，使用`try-finally`或其他方式都可以做得更好、更及时。

#### 第二次标记

在启动完`finalizer`之后，GC将对**F-Queue**中的对象进行第二次小规模的标记，如果对象要在`finalize()`中重新与引用链上的任何一个对象建立了关联，那么在第二次标记时它将被移出“即将回收”的集合；如果对象还是没有建立关联，那么将被GC回收。

# 垃圾收集算法

## 标记 - 清除算法

**标记 - 清除算法**分为”**标记**“和“**清除**”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

标记 - 清除算法是**最基础的算法**，因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。

主要缺点：

1. 效率问题，标记和清除过程的效率都不高
2. 空间间隔，标记清楚之后产生的是大量不连续的内存碎片。空间碎片太多可能会导致当程序需要分配较大对象时无法找到足够的连续内存，而不得不提前触发另一次垃圾收集。

标记 - 清除算法执行过程：![TIM截图20190326145305](/imag/TIM截图20190326145305.png)

## 复制算法

为解决效率问题，**复制算法**出现了。复制算法将内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块内存用完了，就将还存活者的对象复制到另一块上面，然后再将已使用过的内存空间一次清理掉。

这样使得每次都是对其中的一块进行内存回收，分配时也不用考虑内存碎片等复杂情况，实现简单，运行高效。代价是将内存缩小为原来的一半。

主要缺点：

1. 在对象存活率较高时，要执行较多的复制操作，效率将会变低。
2. 空间浪费比较大，为避免浪费50%的空间，需要额外的空间进行分配担保。

复制算法执行过程：

![TIM截图20190326155252](/imag/TIM截图20190326155252.png)

现在的商业虚拟机都采用复制算法来回收新生代，IBM的研究表明，新生代中的对象98%是朝生夕死的，所以不需要按照1：1的比例来划分内存空间，而是将内存分为一块较大的**Eden空间**和两块较小的**Survivor空间**，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活的对象一次性拷贝到另一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot虚拟机默认的Eden和Survivor的大小比例屎8：1，也就是每次新生代中可以用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存是会被浪费的。

## 标记 - 整理算法

**标记 - 整理算法**过程与标记 - 清除算法一样，但是后续的步骤不是直接对可回收的对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

是针对老年代提出的优化算法。

标记 - 整理算法执行过程：

![TIM截图20190326170833](/imag/TIM截图20190326170833.png)

## 分代收集算法

**分代收集算法**只是根据对象的存活周期的不同将内存划分为几块，一般把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适合的收集算法。

在新生代中，每次垃圾收集时都有大批对象被回收，只有少部分对象存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。

老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用**标记 - 清除**或**标记 - 整理**算法来进行回收。

# 垃圾收集器

收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。

图示展示了7中垃圾收集器，相互连线的表示可以搭配使用。

![collectors](/imag/collectors.png)

## Serial收集器

**Serial收集器**是最基本、最早出现的收集器。Serial收集器在新生代中采用**复制算法**，并且是一个单线程的收集器，它的“单线程”的意义不仅仅说明它只使用一个CPU或者一个收集线程，还表示它在进行垃圾收集时，必须暂停其它所有的工作线程（Stop The World），直至收集结束。

对比其他收集器的单线程收集，Serial更为简单高效，在单个CPU环境下，没有线程交互的开销，可以获得最高的单线程收集效率。

## ParNew收集器

**ParNew收集器**其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有可控参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致。

除Serial收集器外，只有ParNew收集器能与CMS收集器配合工作。在单CPU的环境中，ParNew不会有比Serial收集器更好的效果。默认开启的收集线程数与CPU的数量相同，随着可使用CPU的数量的增加，对于HC时系统资源的利用很有好处。

## Parallel Scavenge收集器

**Parallel Scavenge收集器**也是一个新生代收集器，也是使用复制算法，也是并行的多线程收集器。

Parallel Scavenge收集器的特点是关注点与其他收集器不同，其他收集器的关注点是尽可能缩短垃圾收集时用户进程的停顿，而Parallel Scavenge收集器的目标则是达到一个可控的**吞吐量**。

停顿时间越短越适合需要与用户交互的程序，良好的响应速度能提升用户的体验；而高吞吐则可以更高效率得利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。

## Serial Old收集器

**Serial Old收集器**是Serial收集器的老年代版本，同样是一个单线程收集器，但是使用**标记 - 整理算法**。

在Server模式下，主要作用是与Paraller Scavenge收集器搭配使用；作为CMS收集器的后背预案，在并发收集发生`Concurrent Mode Failure`时使用。

## Parallel Old收集器

**Parallel Old收集器**是Parallel Scavenge收集器的老年代版本，使用多线程收集，使用**标记 - 整理算法**。

## CMS收集器

**CMS（Concurrent Mark Sweep）收集器**是一种以获取最短回收停顿时间为目标的老年代收集器。基于**标记 - 清除算法**。

### CMS收集器的运行过程

#### 1. 初始标记（CMS Initial Mark）

标记GC Roots能直接关联到的对象，速度很快。

#### 2. 并发标记（CMS Concurrent Mark）

进行GC Roots Tracing，耗时最长。

#### 3. 最终标记（CMS Remark）

修正并发标记期间，因用户程序继续运作而导致标记变动的那一部分对象的标记记录，停顿时间会比初始标记阶段稍长，但远比并发标记的时间短。

#### 4. 并发清除（CMS Concurrent Sweep）

清除未存活的对象

其中**初始标记**、**重新标记**这两个步骤任然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快。

**并发标记**、**并发清除**是与用户线程一起并发执行的。

### CMS的优缺点分析

#### 优点

- 并发收集
- 低停顿

#### 缺点

- **CMS收集器对CPU资源非常敏感。**CMS默认启动的回收线程数是（CPU数量 + 3）/ 4，即当CPU数量在4个以上时，并发回收线程最多战友不超过25%的CPU资源，但是在CPU数量不足4个时，对用户线程的影响比较大。
- **CMS收集器无法处理浮动垃圾。**由于并发清理阶段用户线程还在运行，自然也会还有新的垃圾不断产生，但这部分垃圾出现在标记过程之后，CMS收集器在本次收集中无法处理它们，只能留待下一次GC时再进行清理，这部分垃圾成为浮动垃圾。正因为浮动垃圾的存在，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满再进行，需要预留一部分空间，默认配置下，老年代空间在使用68%时，CMS收集器将被激活。在CMS运行期间预留的内存无法满足程序需要，会出现一次“Concurrent Mode Failure”，此时虚拟机将启动后备方案，临时启动Serial Old收集器重新进行老年代的垃圾收集。可通过`-XX:CMSInitiatingOccupancyFraction`配置启动时比例。
- **基于标记 - 清除算法，会产生大量空间碎片。**空间碎片过多，在老年代还有空间剩余但是无法找到足够的连续空间分配给大对象时，将会触发一次Full GC。为解决这个问题，CMS收集器提供一个`-XX:+useCMSCompatAtFullCollection`开关参数，在Full GC后开始一个碎片整理过程，但是碎片整理过程无法并发，会增加停顿时间。也可通过配置`-XX:CMSFullGCBeforeCompaction`，配置在执行多少次不压缩的Full GC后，进行一次碎片整理。

## G1收集器

**G1收集器**是一种并发、并行、部分Stop The World，基于复制算法和分代回收算法，回收整个Java堆的收集器，可以非常准确地控制停顿，能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。在JDK1.9中已经成为默认的收集器。

**G1取消了新生代老年代的物理空间**，将整个Java堆（包括新生代、老年代）划分多个大小固定的独立区域（Region），再将Region逻辑划分成Eden、Survivor、Old，在物理上并不连续，这样再也无需对每个代进行设置，担心每个代内存是否够用。在垃圾收集时，G1将对象从一个区域复制到另一个区域，也同时完成了清理工作，避免了内存碎片问题。可通过`-XX:G1HeapRegionSize`设置Region的大小，如果不指定，G1会根据Java堆的大小自动决定。

可通过`-XX:NewRatio=n`来配置新生代与老年代的比例，默认比例为2，即新生代：老年代 = 2：1；可通过`-XX:SurvivorRatio=n`配置Eden与Survivor的比例，默认为8。

![G1 Heap Regions](/imag/g1-011.png)

在G1中，还有一种特殊的区域Humongous区域，如果一个对象占用的空间超过Region大小的一半时，会被放入Humongous Region（巨型区域）中。

### G1 Young GC

**Young GC**主要是对Eden区进行GC，在Eden空间耗尽时被触发，会**Stop The World**，使用多线程并发复制对象，减少GC时间，并通过控制年轻代的Region个数，控制Young GC的时间开销。

在Young GC过程中，需要对对象的存活性进行判断，但根对象可能遍布各个分区，完整扫描会耗费大量时间，G1引进Remembered Set概念，用于跟踪指向某个Heap区内的对象引用。

#### Remembered Set

RSet是辅助GC过程的一种结构，与Card Table类似。RSet记录了其他Region中的对象对本Region中对象的关系属于Points-Into结构（谁引用了我的对象）；Card Table则是一种Points-Out结构（我引用了谁的对象）。G1的RSet是在Card Table的基础上实现的，每个Region记录下别的Region对自己对象的引用，并标记这些引用分别在哪些Card的范围内，RSet其实是一个HashTable，Key是别的Region的起始地址，Vlued是一个集合，里面的元素是Card Table的Index。

![Remembered Set](/imag/fig1.jpg)

图中每个Region被分成了多个Card，不同Region中的Card会相互引用，如Region1中的Card对象引用了Region2中Card中的对象。蓝色实线表示的就是Points-Out关系，而在Region2的RSet中，记录了Region1的Card，即红色虚线表示的关系，是Points-Into关系。

RSet中的引用关系靠Post-Write Barrier和Concurrent Refinement Threads来维护，Post-Write Barrier记录了跨Region的引用更新，更新日志缓冲区记录那些包含更新引用的Card，缓冲区满了之后，Post-Write Barrier停止服务，由Concurrent Refinement Threads开始处理缓冲区的日志。

在Young GC中，选定年轻代的RSet作为根集，这些RSet记录了老年代对年轻代的跨代引用，避免扫描整个老年代。而在Mixed GC中，老年代中的RSet记录了老年代对老年代的引用，年轻代对老年代的引用则由扫描全部年轻代获得。避免了对老年代的整体扫描，大大减少了GC的工作量。

### Mixed GC

**Mixed GC**会回收所有新生代的Region，分为Global Concurrent Marking（全局并发标记）和evacuation（拷贝存活对象）两步。

首先根据Global Concurrent Marking，可以知道老年代Region中有多少空间要被回收以及收集收益高的若干老年代Region，在每次Young GC之后和再次发生Mixed GC之前，会检查垃圾占比是否达到`--X:G1MixedGCLiveThresholdPercent`老年代中存活对象占比参数，在达到后的下一次检查，就会在用户指定的开销目标范围内尽可能选择收益高的老年代Region进行evacuation，最终完成收集释放空间。

#### Global Concurrent Marking

Global Concurrent Marking全局并发标记主要为Mix GC提供标记服务，并不是一次GC过程的必须环节。全局并发标记过程分为五个阶段

##### 1. 初始标记（Initial Mark ）

是一个STW事件，负责完成标记GC Roots直接关联的对象，并将他们的字段压入Marking Stack（扫描栈）中等待后续扫描。因为是STW事件，通常会在Young GC的时候共用Young GC的STW，复用Root Scan，所以可以说全局并发标记是伴随着Young GC而发生的。

##### 2. 根区域扫描（Root Region Scan ）

根区域扫描是从Survior区的对象出发，标记被引用到老年代中的对象，并把它们的字段压入Marking Stack中等待后续扫描。此阶段是与应用程序并发运行的，不会被STW打断，并且必须在Young GC开始前完成，如果恰好新生代在根区域扫描过程中满了，需要进行Young GC，Young GC会进行等待。

##### 3. 并发标记（Concurrent Mark ）

并发标记与用户进程并行执行，不断从Marking Stack中取出引用递归，扫描堆里的对象压入Marking Stack并对其进行标记，直至Marking Stack被清空。

##### 4. 最终标记（Remark）

最终标记是一个STW事件，处理并发标记完成后，Java线程剩下的未处理的SATB Write Barrier记录。同时此阶段也进行弱引用处理。

##### 5. 清除（Cleanup）

CleanUp是一个SWT事件，负责清点出所有存活对象的Region和没有存活对象的Region，并且更新RSet。

紧跟其后的Concurrent Cleanup是一个并发事件，负责清空没有存活对象的Region，并加入到Free List中。

#### 三色标记算法



# 附录

## 引用

无论是通过**引用计数法**还是**根搜索算法**判断对象的引用链是否可达，判断对象是否存活都与**引用**有关。

JDK1.2之前，Java对引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。

JDK1.2之后，Java对引用的概念进行了扩充，将引用分为**强引用（Strong Reference）**、**软引用（Soft Reference）**、**弱引用（Weak Reference）**、**虚引用（Phantom Reference）**，这四种引用强度依次逐渐减弱。

### 强引用

**强引用**就是指在程序代码中普遍存在的，类似`Object obj = new() Object()`这类的引用，只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。

### 软引用

**软引用**用来描述一些还有用，但是非必需的对象。对于软引用关联的对象，在系统将要发生内存溢出之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，将会抛出`OutOfMemoryError`异常。JDK1.2之后，提供`java.lang.ref.SoftReference<T>`实现。

### 弱引用

**弱引用**也是用来描述非必需对象的，强度比软引用更弱一些。被弱引用光联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。JDK1.2之后，提供`java.lang.ref.WeakReference`实现。

### 虚引用

**虚引用**是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。JDK1.2之后，提供`java.lang.ref.PhantomReference`实现。