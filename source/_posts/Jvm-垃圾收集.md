---
title: Jvm-垃圾收集
date: 2019-03-20 21:00:00
categories: Jvm
tags: [Jvm,垃圾收集]
---

# 概述

**垃圾收集（Garbage Collection，GC）**最早起源于Lisp语言，是一种自动的存储管理机制。在Java中，垃圾收集是JVM中重要的组成部分。当需要排查各种内存溢出、内存泄漏问题时，以及垃圾收集称为系统达到更高并发量的瓶颈时，我们就需要对这些“自动化”技术实施必要的监控和调节。

在Java堆中，一个接口的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，只有在程序处于运行期间时才能知道创建哪些对象，这部分内存的分配和回收都是动态的，这就是垃圾收集所关注的内存。

<!--more-->

# 对象存活判断算法

## 引用计数法

**引用计数法**是指给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能再被使用的。

引用计数法难以解决对象之间相互循环引用的问题，例如

```Java
public class ReferenceCounting {

    private ReferenceCounting rc;

    public static void main(String[] args) {
        ReferenceCounting rc1 = new ReferenceCounting();
        ReferenceCounting rc2 = new ReferenceCounting();
        rc1.rc = rc2;
        rc2.rc = rc1;

        rc1 = null;
        rc2 = null;
    }
}
```

创建相互引用的`rc1`和`rc2`，随后赋值为`null`。此时因为两对象的相互引用，即使`rc1`,`rc2`都不再指向对象，但是对象的引用计数器都不为0，所以无法被回收。

## 根搜索算法

**根搜索算法**是指通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为*引用链（Reference Chain）*，当一个对象到GC Roots没有任何引用链相连（即从*GC Roots* 到这个对象不可达）时，则证明此对象是不可用的。

如下图中的*Object1*，*Object2*，*Object3*，*Object4*是可以通过*GC Roots* 到达的，即为可用对象；*Object5*，*Object6*，*Object7* 对象之间有关联，但不可通过*GC Roots* 到达，即为不可用对象。

![根搜索算法](E:/jccc.me/source/_posts/imag/根搜索算法.png)

在Java中，可作为*GC Roots* 的对象包括下面几种

- 虚拟机栈（栈帧中的本地变量表）中的引用的对象
- 方法区中的静态类属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中`native`方法的引用的对象

### 二次标记

在根搜索算法中不可到达的对象，并非是一定会被回收的，真正回收一个对象，至少要经历**两次标记过程**。

#### 第一次标记

如果对象在进行根搜索后发现没有与*GC Roots* 相连接的引用链，那么她将会被第一次标记，并且进行一次筛选，筛选的条件是此对象是否有必要执行`finalize()`方法。当对象没有重写`finalize()`方法，或者`finalize()`方法已经被虚拟机调用过，则被视为没有必要。

如果这个对象被判定为有必要执行`finalize()`方法，那么这个对象会被放置在一个名为**F-Queue**的队列之中，并在稍后由一条虚拟机创建、低优先级的`Finalizer`线程去执行。此处的执行指的是虚拟机会触发这个方法，但并不承诺等待它运行结束。

#### `finalize()`方法

任何一个对象的`finalize()`方法都只会被系统自动调用一次，如果对象面临下一次回收，它的`finalize()`方法不会再次被执行。

并不建议使用`finalize()`方法，因为它不是C/C++中的析构函数，运行代价高昂，不确定性大，无法保证各个对象的调用顺序。`finalize()`方法能做的所有工作，使用`try-finally`或其他方式都可以做得更好、更及时。

#### 第二次标记

在启动完`finalizer`之后，GC将对**F-Queue**中的对象进行第二次小规模的标记，如果对象要在`finalize()`中重新与引用链上的任何一个对象建立了关联，那么在第二次标记时它将被移出“即将回收”的集合；如果对象还是没有建立关联，那么将被GC回收。

# 垃圾收集算法

## 标记 - 清除算法

**标记 - 清除算法**分为”**标记**“和“**清除**”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

标记 - 清除算法是**最基础的算法**，因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。

主要缺点：

1. 效率问题，标记和清除过程的效率都不高
2. 空间间隔，标记清楚之后产生的是大量不连续的内存碎片。空间碎片太多可能会导致当程序需要分配较大对象时无法找到足够的连续内存，而不得不提前触发另一次垃圾收集。

标记 - 清除算法执行过程：![TIM截图20190326145305](/imag/TIM截图20190326145305.png)

## 复制算法

为解决效率问题，**复制算法**出现了。复制算法将内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块内存用完了，就将还存活者的对象复制到另一块上面，然后再将已使用过的内存空间一次清理掉。

这样使得每次都是对其中的一块进行内存回收，分配时也不用考虑内存碎片等复杂情况，实现简单，运行高效。代价是将内存缩小为原来的一半。

主要缺点：

1. 在对象存活率较高时，要执行较多的复制操作，效率将会变低。
2. 空间浪费比较大，未避免浪费50%的空间，需要额外的空间进行分配担保。

复制算法执行过程：

![TIM截图20190326155252](/imag/TIM截图20190326155252.png)

现在的商业虚拟机都采用复制算法来回收新生代，IBM的研究表明，新生代中的对象98%是朝生夕死的，所以不需要按照1：1的比例来划分内存空间，而是将内存分为一块较大的**Eden空间**和两块较小的**Survivor空间**，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活的对象一次性拷贝到另一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot虚拟机默认的Eden和Survivor的大小比例屎8：1，也就是每次新生代中可以用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存是会被浪费的。

## 标记 - 整理算法

**标记 - 整理算法**过程与标记 - 清除算法一样，但是后续的步骤不是直接对可回收的对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

是针对老年代提出的优化算法。

标记 - 整理算法执行过程：

![TIM截图20190326170833](/imag/TIM截图20190326170833.png)

## 分代收集算法

**分代收集算法**只是根据对象的存活周期的不同将内存划分为几块，一般把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适合的收集算法。

在新生代中，每次垃圾收集时都有大批对象被回收，只有少部分对象存货，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。

老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用**标记 - 清除**或**标记 - 整理**算法来进行回收。

# 垃圾收集器

# 附录

## 引用

无论是通过**引用计数法**还是**根搜索算法**判断对象的引用链是否可达，判断对象是否存活都与**引用**有关。

JDK1.2之前，Java对引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。

JDK1.2之后，Java对引用的概念进行了扩充，将引用分为**强引用（Strong Reference）**、**软引用（Soft Reference）**、**弱引用（Weak Reference）**、**虚引用（Phantom Reference）**，这四种引用强度依次逐渐减弱。

### 强引用

**强引用**就是指在程序代码中普遍存在的，类似`Object obj = new() Object()`这类的引用，只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。

### 软引用

**软引用**用来描述一些还有用，但是非必需的对象。对于软引用关联的对象，在系统将要发生内存溢出之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，将会抛出`OutOfMemoryError`异常。JDK1.2之后，提供`java.lang.ref.SoftReference<T>`实现。

### 弱引用

**弱引用**也是用来描述非必需对象的，强度比软引用更弱一些。被弱引用光联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。JDK1.2之后，提供`java.lang.ref.WeakReference`实现。

### 虚引用

**虚引用**是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。JDK1.2之后，提供`java.lang.ref.PhantomReference`实现。