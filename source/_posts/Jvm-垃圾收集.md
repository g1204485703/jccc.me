---
title: Jvm-垃圾收集
date: 2019-03-20 21:00:00
categories: Jvm
tags: [Jvm,垃圾收集]
---

# 概述

**垃圾收集（Garbage Collection，GC）**最早起源于Lisp语言，是一种自动的存储管理机制。在Java中，垃圾收集是JVM中重要的组成部分。当需要排查各种内存溢出、内存泄漏问题时，以及垃圾收集称为系统达到更高并发量的瓶颈时，我们就需要对这些“自动化”技术实施必要的监控和调节。

在Java堆中，一个接口的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，只有在程序处于运行期间时才能知道创建哪些对象，这部分内存的分配和回收都是动态的，这就是垃圾收集所关注的内存。

<!--more-->

# 对象存活判断算法

## 引用计数法

**引用计数法**是指给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能再被使用的。

引用计数法难以解决对象之间相互循环引用的问题，例如

```Java
public class ReferenceCounting {

    private ReferenceCounting rc;

    public static void main(String[] args) {
        ReferenceCounting rc1 = new ReferenceCounting();
        ReferenceCounting rc2 = new ReferenceCounting();
        rc1.rc = rc2;
        rc2.rc = rc1;

        rc1 = null;
        rc2 = null;
    }
}
```

创建相互引用的`rc1`和`rc2`，随后赋值为`null`。此时因为两对象的相互引用，即使`rc1`,`rc2`都不再指向对象，但是对象的引用计数器都不为0，所以无法被回收。

## 根搜索算法

**根搜索算法**是指通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为*引用链（Reference Chain）*，当一个对象到GC Roots没有任何引用链相连（即从*GC Roots* 到这个对象不可达）时，则证明此对象是不可用的。

如下图中的*Object1*，*Object2*，*Object3*，*Object4*是可以通过*GC Roots* 到达的，即为可用对象；*Object5*，*Object6*，*Object7* 对象之间有关联，但不可通过*GC Roots* 到达，即为不可用对象。

![根搜索算法](E:/jccc.me/source/_posts/imag/根搜索算法.png)

在Java中，可作为*GC Roots* 的对象包括下面几种

- 虚拟机栈（栈帧中的本地变量表）中的引用的对象
- 方法区中的静态类属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中`native`方法的引用的对象

### 二次标记

在根搜索算法中不可到达的对象，并非是一定会被回收的，真正回收一个对象，至少要经历**两次标记过程**。

#### 第一次标记

如果对象在进行根搜索后发现没有与*GC Roots* 相连接的引用链，那么她将会被第一次标记，并且进行一次筛选，筛选的条件是此对象是否有必要执行`finalize()`方法。当对象没有重写`finalize()`方法，或者`finalize()`方法已经被虚拟机调用过，则被视为没有必要。

如果这个对象被判定为有必要执行`finalize()`方法，那么这个对象会被放置在一个名为**F-Queue**的队列之中，并在稍后由一条虚拟机创建、低优先级的`Finalizer`线程去执行。此处的执行指的是虚拟机会触发这个方法，但并不承诺等待它运行结束。

#### `finalize()`方法

任何一个对象的`finalize()`方法都只会被系统自动调用一次，如果对象面临下一次回收，它的`finalize()`方法不会再次被执行。

并不建议使用`finalize()`方法，因为它不是C/C++中的析构函数，运行代价高昂，不确定性大，无法保证各个对象的调用顺序。`finalize()`方法能做的所有工作，使用`try-finally`或其他方式都可以做得更好、更及时。

#### 第二次标记

在启动完`finalizer`之后，GC将对**F-Queue**中的对象进行第二次小规模的标记，如果对象要在`finalize()`中重新与引用链上的任何一个对象建立了关联，那么在第二次标记时它将被移出“即将回收”的集合；如果对象还是没有建立关联，那么将被GC回收。

# 垃圾收集算法



# 附录

## 引用

无论是通过**引用计数法**还是**根搜索算法**判断对象的引用链是否可达，判断对象是否存活都与**引用**有关。

JDK1.2之前，Java对引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。

JDK1.2之后，Java对引用的概念进行了扩充，将引用分为**强引用（Strong Reference）**、**软引用（Soft Reference）**、**弱引用（Weak Reference）**、**虚引用（Phantom Reference）**，这四种引用强度依次逐渐减弱。

### 强引用

**强引用**就是指在程序代码中普遍存在的，类似`Object obj = new() Object()`这类的引用，只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。

### 软引用

**软引用**用来描述一些还有用，但是非必需的对象。对于软引用关联的对象，在系统将要发生内存溢出之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，将会抛出`OutOfMemoryError`异常。JDK1.2之后，提供`java.lang.ref.SoftReference<T>`实现。

### 弱引用

**弱引用**也是用来描述非必需对象的，强度比软引用更弱一些。被弱引用光联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。JDK1.2之后，提供`java.lang.ref.WeakReference`实现。

### 虚引用

**虚引用**是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。JDK1.2之后，提供`java.lang.ref.PhantomReference`实现。