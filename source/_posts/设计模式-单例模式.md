---
title: 设计模式-单例模式
date: 2019-03-11 19:30:00
categories: 设计模式
tags: [设计模式,单例模式]
---

# 定义

[菜鸟教程](http://www.runoob.com/design-pattern/singleton-pattern.html)中如下定义

> 单例模式（Singleton Pattern）是Java中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的方式，可以直接访问，不需要实例化该类的对象。

特点：

- 单例类只能有一个实例。
- 单例类必须自己创建自己的唯一实例。
- 单例类必须给所有其他对象提供这一实例。

<!--more-->

# 实现

## 懒汉式

### 线程不安全，Lazy初始化

优点：简单；Lazy初始化，不浪费内存

缺点：线程不安全

```Java
public class LazyUnsafeSingletion {
    private static LazyUnsafeSingletion singletion;

    public LazyUnsafeSingletion() {}

    public static LazyUnsafeSingletion getInstance() {
        if (singletion == null)
            return singletion = new LazyUnsafeSingletion();
        return singletion;
    }
}
```

### 线程安全，Lazy初始化

优点：简单；线程安全；Lazy初始化，不浪费内存

缺点：锁定整个`getInstance()`方法，效率低

使用`synchronized`修饰`getInstance`方法，保证线程安全。

```Java
public class LazySafeSingletion {
    private static LazySafeSingletion singletion;

    public LazySafeSingletion() {}

    private synchronized LazySafeSingletion getInstance() {
        if (singletion == null)
            return singletion = new LazySafeSingletion();
        return singletion;
    }
}
```

## 饿汉

线程安全，非Lazy

优点：简单；线程安全；效率高

缺点：类加载时就初始化，浪费内存

```Java
public class HungerSingleton {
    private static final HungerSingleton SINGLETON = new HungerSingleton();

    public HungerSingleton(){}

    public static HungerSingleton getInstance(){
        return SINGLETON;
    }
}
```

## 双检锁/双重校验锁

优点：线程安全；Lazy初始化；仅在`singleton == null`锁定单例类，效率较高

```Java
public class DLCSingleton {
    private volatile static DLCSingleton singleton;

    public DLCSingleton() {}

    public static DLCSingleton getInstance() {
        if (singleton == null) {
            synchronized (DLCSingleton.class) {
                if (singleton == null)
                    singleton = new DLCSingleton();
            }
        }
        return singleton;
    }
}
```

## 内部类

内部类利用ClassLoader机制保证初始化`SINGLETON`时只有一个进程，并且达到Lazy加载。

```Java
public class InnerSingleton {
    public InnerSingleton(){}

    private static class SingletonHolder{
        private static final InnerSingleton SINGLETON = new InnerSingleton();
    }

    public static InnerSingleton getInstance(){
        return SingletonHolder.SINGLETON;
    }
}
```

## 枚举

枚举方式构造单例不仅能避免多线程同步问题，还可以自动支持序列化机制，防止反序列化重新创建新的对象。

```Java
public enum EnumSingleton {
    SINGLETON;
}
```

