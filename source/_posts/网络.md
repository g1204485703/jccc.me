---
title: 网络
date: 2019-03-04 09:30:00
categories: Java
tags: [网络,tcp,udp]
---

# 网络体系结构

## 网络架构

![img](/imag/1628186c40210f2e)

<!--more-->

### OSI的七层协议

#### 应用层

应用层提供为应用软件而设的接口，以设置与另一应用软件之间的通信。例如：HTTP，HTTPS，FTP，TELNET，SSH，SMTP，POP3等

#### 表示层

表示层把数据转换为能与接收者的系统格式兼容并适合传输的格式。

#### 会话层

会话层负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接。

#### 传输层

传输层把传输表头（TH）加至数据以形成数据包。

#### 网络层

网络层决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组。网络表头包含了网络数据。例如：互联网协议（IP）等。

#### 数据链路层

数据链路层负责网络寻址，错误侦测和改错。当表头和表尾被加至数据包时，会形成帧。

#### 物理层

物理层在局域网上传送数据帧，它负责管理计算机通信设备和网络媒体之间的互通。

## 传输层协议

### TCP

TCP提供一种面向连接的、可靠的字节流服务

#### 保证可靠

依赖超时重传，重复累计确认保证可靠性。

#### TCP三次握手

![1552292299878](/imag/1552292299878.png)

1. 客户端通过向服务端发送一个**SYN**来创建一个主动打开，作为三路握手的一部分。客户端把这段连接的序号设定为随机数**A**。
2. 服务端应当为一个合法的**SYN**回送一个**SYN**/**ACK**。**ACK**的确认码应为**A+1**，**SYN**/**ACK**包本身又有一个随机产生的序号**B**。
3. 最后，客户端再发送一个**ACK**。当服务端收到这个**ACK**的时候，就完成了三路握手，并进入了连接创建状态。此时包序号被设定为收到的确认号**A+1**,相应号则为**B+1**。

如果在第三步时，服务端没有收到客户端发送的**ACK**，此时连接处于一个中间状态，即没有成功，也没有失败。服务端会在一段时间内重发**SYN**/**ACK**。在Linux下，默认会重试5次，重试的间隔时间从1s开始翻倍，即5次的重试间隔为1s，2s，4s，8s，16s，最后一次16s的重试需要在32s后才能得知超时，即一共需要63s，TCP才会断开这个连接。

#### TCP四次挥手

终结连接的操作客户端和服务端都可以发起。

以客户端发起举例：

1. 客户端完成信息发送，则对服务端发送**FIN**表示终结连接，表示客户端已经没有数据要发送给服务端了，进入**FIN_WAIT_1**状态。可以继续接收来自服务端的数据。
2. 服务端接收到**FIN**请求后，返回**ACK**表示确认。此时客户端进入**FIN_WAIT_2**状态。
3. 服务端在数据发送完成后，向客户端发送**FIN**请求终结连接。
4. 客户端向服务端返回**ACK**，并进入**TIME_WAIT**状态。等待**2MSL**（最大报文生存时间），后客户端关闭连接。服务端则在收到**ACK**后就关闭连接。

![Deconnection_TCP](/imag/Deconnection_TCP.png)

#### 为什么连接是三次握手，终结却是四次挥手？

创建连接时，客户端向服务端发送SYN连接报文后，服务端可以同时将ACK+SYN报文发送给客户端，其中ACK用于应答客户端的连接请求，SYN用于同步。在关闭连接的时候，服务端收到FIN报文时，并不一定自身也是可关闭状态，所以先发送一个ACK，应答客户端的FIN请求，并在数据发送完成后，再发送FIN请求。

#### 为什么TIME_WAIT状态需要经过2MSL（最大报文生存时间）才能返回到CLOSE状态？

- 保证最后发送的ACK能够到达服务端。
- 防止本次的已经失效的报文段出现再下一个新的连接中。

### UDP

用户数据包协议（英语：User  Datagram Protocol，缩写：UDP），又称用户数据包协议，是一个简单的面向数据报的传输层协议。

在TCP/IP模型中，UDP为网络层以上和应用层以下提供了一个简单的接口。UDP只提供数据的不可靠传递，它一旦把应用程序发给网络层的数据发送出去，就不保留数据备份（所以UDP有时候也被认为是不可靠的数据报协议）。UDP在IP数据报的头部仅仅加入了复用和数据校验（字段）。