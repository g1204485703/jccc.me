---
title: Jvm-内存结构
date: 2019-03-12 10:30:00
categories: Jvm
tags: [Jvm,Jvm内存结构]
---

# JVM内存模型

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有的区域则是依赖用户线程的启动和结束而建立和销毁。

![JVM运行时内存结构](/imag/QQ20180624-150918.png)

<!--more-->

## PC寄存器

**PC寄存器（计数器）**是一块较小的内存空间，它的作用可以看作是当前线程所执行的字节码的行号指示器。在虚拟机概念模型中，字节码解释器的工作就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。例如：分支、循环、跳转、异常寄存器处理、线程恢复等功能都需要依赖这个寄存器完成。

Java虚拟机支持多线程，通过线程轮流切换并分配处理器执行时间实现。任一时刻，一个处理器（内核）仅执行一条线程中的指令。故，为了线程切换后能恢复到正确的执行位置，每个线程都需要拥有自己独立的PC寄存器，各线程之间的寄存器互不影响。

线程正在执行的方法如果不是`native`的，则PC寄存器记录当前正在执行的Java虚拟机指令的地址。如果线程当前执行的方法是`natice`的，则Java虚拟机的PC寄存器的值是`Undefined`。

PC寄存器是唯一一个在`Java虚拟机规范`中没有规定`OutOfMemoryError`情况的区域。

## Java虚拟机栈

**Java虚拟机栈**描述的是Java方法执行的内存模型，每个方法被执行的时候都会创建一个**栈帧**用于存储**局部变量表**、**操作栈**、**动态链接**、**方法出口**等信息也是线程私有，生命周期与线程相同。每个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

Java虚拟机栈也就是内存粗糙划分为**堆内存（Heap）**和**栈内存（Stack）**中的栈内存。

**局部变量表**中存放了编译器可知的各类基本**数据类型**（`boolean`、`byte`、`char`、`short`、`int`、`float`、`long`、`double`）、**对象引用**（reference类型，不等同于对象本身，根据不同的虚拟机实现，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和**returnAddress**类型（指向了一条字节码指令的地址）。

64位长度的`long`和`double`类型的数据会占用2个局部变量空间（Slot），其余类型的数据只占用1个。局部变量表所需的内存在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

如果线程请求的栈深度大于虚拟机所允许的深度，将抛出`StackOverflowError`异常。

如果动态扩展时无法申请到足够的内存、栈不足以初始化一个新线程时会抛出`OutOfMemoryError`异常。

## 本地方法栈

**本地方法栈**与虚拟机栈类似，虚拟机栈为虚拟机执行的Java方法服务，而本地方法栈则是为虚拟机使用到的`native`方法服务。

虚拟机规范中对本地方法栈中的方法使用的语言、使用方式以及数据结构并没有强制规定，由虚拟机自由实现。甚至有的虚拟机（HotSpot）直接就把本地方法栈和虚拟机栈合二为一。

本地方法栈也会抛出`StackOverflowError`、`OutOfMemoryError`异常。

## Java堆

Java堆是Java虚拟机所管理的内存中最大的一块，在虚拟机启动时创建，被所有线程共享的一块内存区域。Java堆的唯一目的就是存放对象实例，几乎所有的对象实例都可以在这里分配内存。

Java堆是垃圾收集器（*garbage collector*、*GC*）管理的主要区域。从内存回收的角度看，由于现在收集器基本采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代。再细致一点还有Eden空间、From Survivor空间、To Survivor空间等。

Java虚拟机规范规定，Java堆可以处于物理上不连续的内存空间中，只要在逻辑上是连续的即可。在实现时，既可以实现成固定大小，也可以是扩展的，当前主流的虚拟机都是按照可扩展来实现，通过初始堆大小（-Xms）、最大堆大小（-Xmx）等控制。

如果堆中没有内存可用于完成实例分配，且堆也无法再扩展时，将会抛出`OutOfMemoryError`异常。

## 方法区

方法区在虚拟机启动时创建，也是各个线程共享的内存区域，用于存储已被虚拟机加载的**类信息**、**常量**、**静态变量**、**即时编译器编译后的代码**等数据。虽然在逻辑上是堆的一部分，但是却有一个别名叫做Non-Heap，与Java堆区分开。

HotSpot在jkd1.6以及之前的版本中将永久代（Permanent Generation）作为方法区的实现，在永久代空间不足时会抛出`OutOfMemoryErrot:permGen space`。在jkd1.7中将永久代的部分数据（*字符串常量*、*静态变量*）转移到了**Java堆**；在jkd1.8中，完全移除了持久代这个区域，以元空间（Metaspace）取而代之。

方法区一样不需要连续的内存，可以选择固定大小或者可扩展，也可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现，内存回收的主要目标是针对**常量池的回收**和对**类型的卸载**。

当方法区无法满足内存分配需求时，将抛出`OutOfMemoryError`异常。

### 运行时常量池

**运行时常量池**是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种**字面量**和**符号引用**（一般来说，*解析* 后的**直接引用**也存储在运行时常量池中）。

运行时常量池具备动态性，并不要求常量一定只能在编译期产生，即并非只有Class文件中常量池的内容才能进入运行时常量池，运行期间也可能将新的常量放入常量池中。例如`String`类中的`intern()`方法。

运行时常量池是方法区的一部分，同样受到方法区内存的限制，当常量池无法再申请到内存是抛出`OutOfMemoryError`异常。

# 附录

## 字面量

```Java
// 变量 
int a;
// b为常量 10为字面量
final int b = 10; 
// 静态变量
static int c；
// 静态常量
final static int c = 10；
// string为常量 helloWorld为字面量
String string = “helloWorld”；
```

## 符合引用

符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。例如，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。

## 直接引用

直接引用可以是

1. 直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）
2. 相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）
3. 一个能间接定位到目标的句柄

直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。

  